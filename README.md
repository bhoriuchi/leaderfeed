# leaderfeed
Leader election for subscription/changefeed databases

## About

`leaderfeed` is a simple leader election library for use with databases that support subscriptions/changefeeds.

The election algorithm borrows from [`raft`](https://raft.github.io/) but has no concept of terms or log distribution.

### Example (ES6)

```js
import rethinkdbdash from 'rethinkdbdash'
import leaderfeed from 'leaderfeed'

const table = 'mytable'

// initialize
const feedA = new leaderfeed.RethinkDB(rethinkdbdash)
const feedB = new leaderfeed.RethinkDB(rethinkdbdash)

// add events
feedA.on('new state', state => console.log('feedA state changed to ', state))
feedB.on('new state', state => console.log('feedB state changed to ', state))

// start nodes
feedA.start({ table }, (error, feed) => {
  if (error) return console.error(error)
  
  let { r, db, table } = feed
  // issue commands
  r.db(db).table(table).run()
})

feedB.start({ table }, (error, feed) => {
  if (error) return console.error(error)
    
  // check if leader
  console.log('feedB is leader: ', feed.isLeader)
})

```

### API

#### LeaderFeed#RethinkDB(`driver` [,`db:String`] [,`opts:Object`]) => `RethinkLeaderFeed`

Initializes a new `RethinkLeaderFeed`

* [`db="test"`] - database name
* [`opts`] - extended rethinkdb connection options
  * [`opts.heartbeatIntervalMs=1000`] - time between heartbeat updates
  * [`opts.electionTimeoutMinMs=3000`] - minimum time before self electing, should be at least `heartbeatIntervalMs * 2`
  * [`opts.electionTimeoutMaxMs=6000`] - maximum time before self electing, should be at least `electionTimeoutMaxMs * 2`

#### RethinkLeaderFeed#start(`opts:Object` [,`cb:Function`]) => `Promise<RethinkLeaderFeed>`

Starts the leaderfeed

* `opts` - options hash
  * `opts.table` - table name
  * [`opts.connection`] - rethinkdb connection
* [`cb`] - callback, returns error as first argument or leader feed as second

#### RethinkLeaderFeed#r => `Driver`

RethinkDB driver

#### RethinkLeaderFeed#connection => `Object`

RethinkDB connection (undefined if driver is `rethinkdbdash`)

#### RethinkLeaderFeed#collection => `Selection`

Shortcut for `r.db(databaseName).table(tableName)`

#### RethinkLeaderFeed#id => `String`

#### RethinkLeaderFeed#isLeader => `Boolean`

#### RethinkLeaderFeed#db => `String`

#### RethinkLeaderFeed#table => `String`



---

### Events

#### `change` => `{ new_val, old_val }`

Fired when data other than the leader metadata has been modified

#### `new state` => `state`

Fired when the leaderfeed's state changes. State is `follower` or `leader`

#### `new leader` => `leaderId`

Fired when a new leader is elected

---

### Summary of algorithm

leaderfeed leverages changefeeds/subscriptions to determine node health. Unlike a leader in [`raft`](https://raft.github.io/), the leaderfeed leader does not distribute logs or calculate consensus. A leaderfeed cluster simply assigns one node the role of leader and because of this a lot of complexity is removed. Nodes can dynamically join/leave a leaderfeed cluster as long as they have access to the same changefeed/subscription

#### Metadata

* A single record of metadata is stored on a medium that supports change feeds
  * The metadata contains the current leader's id and last check in timestamp

#### Heartbeats

* Heartbeats are committed to the leader metadata record on a set interval by the leader
* Heartbeats consist of the leader's id and the current timestamp
  * the timestamp should be generated by the store (i.e. rethinkdb r.now())

#### Leaderfeeds

* A leaderfeed can be in one of 2 states `follower` or `leader`
* All leaderfeeds start with the state `follower`
* Each leaderfeed uses a randomized election timeout
  * If the election timeout is reached and no updates to the leader metadata have taken place the leaderfeed elects itself and begins sending heartbeats to the store
  * Election timeouts are randomized to prevent multiple leaderfeeds from self electing (see [`raft`](https://raft.github.io/) paper)
* One record is used to store metadata on who the current leader is
* All leaderfeeds set up a changefeed/subscription to the data source on start up
  * If there is an error in the changefeed/subscription, the leaderfeed converts to `follower`
  * If there is a change to the leader metadata (a heartbeat is sent)
    * Election timeout is reset
    * If the leaderfeed has it state set to `leader` and the changefeed metadata identifies another id as the leader, the leaderfeed transitions to `follower` state